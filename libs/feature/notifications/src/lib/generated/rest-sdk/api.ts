/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateWebhookDto
 */
export interface CreateWebhookDto {
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'endpoint': string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateWebhookDto
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof CreateWebhookDto
     */
    'headers'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof CreateWebhookDto
     */
    'requestTimeout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateWebhookDto
     */
    'workUntilDate'?: string | null;
}
/**
 * 
 * @export
 * @interface FindManyNotificationResponse
 */
export interface FindManyNotificationResponse {
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof FindManyNotificationResponse
     */
    'notifications': Array<NotificationsEvent>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyNotificationResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyResponseMeta
 */
export interface FindManyResponseMeta {
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'curPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'perPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindManyResponseMeta
     */
    'totalResults': number;
}
/**
 * 
 * @export
 * @interface FindManyWebhookLogResponse
 */
export interface FindManyWebhookLogResponse {
    /**
     * 
     * @type {Array<WebhookLog>}
     * @memberof FindManyWebhookLogResponse
     */
    'webhookLogs': Array<WebhookLog>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyWebhookLogResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface FindManyWebhookResponse
 */
export interface FindManyWebhookResponse {
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof FindManyWebhookResponse
     */
    'webhooks': Array<Webhook>;
    /**
     * 
     * @type {FindManyResponseMeta}
     * @memberof FindManyWebhookResponse
     */
    'meta': FindManyResponseMeta;
}
/**
 * 
 * @export
 * @interface NotificationsControllerFindMany400Response
 */
export interface NotificationsControllerFindMany400Response {
    /**
     * Notifications error (NOTIFICATIONS-000), Tenant ID not set (NOTIFICATIONS-001), User ID not set (NOTIFICATIONS-002), Forbidden (NOTIFICATIONS-003)
     * @type {string}
     * @memberof NotificationsControllerFindMany400Response
     */
    'message': string;
    /**
     * 
     * @type {NotificationsErrorEnum}
     * @memberof NotificationsControllerFindMany400Response
     */
    'code': NotificationsErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof NotificationsControllerFindMany400Response
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @interface NotificationsEntities
 */
export interface NotificationsEntities {
    /**
     * 
     * @type {NotificationsUserScalarFieldEnum}
     * @memberof NotificationsEntities
     */
    'NotificationsUser': NotificationsUserScalarFieldEnum;
    /**
     * 
     * @type {NotificationsEventScalarFieldEnum}
     * @memberof NotificationsEntities
     */
    'NotificationsEvent': NotificationsEventScalarFieldEnum;
}


/**
 * 
 * @export
 * @interface NotificationsError
 */
export interface NotificationsError {
    /**
     * Notifications error (NOTIFICATIONS-000), Tenant ID not set (NOTIFICATIONS-001), User ID not set (NOTIFICATIONS-002), Forbidden (NOTIFICATIONS-003)
     * @type {string}
     * @memberof NotificationsError
     */
    'message': string;
    /**
     * 
     * @type {NotificationsErrorEnum}
     * @memberof NotificationsError
     */
    'code': NotificationsErrorEnum;
    /**
     * 
     * @type {object}
     * @memberof NotificationsError
     */
    'metadata'?: object;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsErrorEnum = {
    Notifications000: 'NOTIFICATIONS-000',
    Notifications001: 'NOTIFICATIONS-001',
    Notifications002: 'NOTIFICATIONS-002',
    Notifications003: 'NOTIFICATIONS-003'
} as const;

export type NotificationsErrorEnum = typeof NotificationsErrorEnum[keyof typeof NotificationsErrorEnum];


/**
 * 
 * @export
 * @interface NotificationsEvent
 */
export interface NotificationsEvent {
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'operationName': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'html': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'text': string | null;
    /**
     * 
     * @type {number}
     * @memberof NotificationsEvent
     */
    'attempt': number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationsEvent
     */
    'used': boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'error': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'senderUserId': string | null;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'senderData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'recipientGroupId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'recipientUserId': string;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEvent
     */
    'recipientData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEvent
     */
    'updatedAt': string;
    /**
     * 
     * @type {NotificationsUser}
     * @memberof NotificationsEvent
     */
    'NotificationsUser_NotificationsEvent_recipientUserIdToNotificationsUser'?: NotificationsUser;
    /**
     * 
     * @type {NotificationsUser}
     * @memberof NotificationsEvent
     */
    'NotificationsUser_NotificationsEvent_senderUserIdToNotificationsUser'?: NotificationsUser | null;
}
/**
 * 
 * @export
 * @interface NotificationsEventDto
 */
export interface NotificationsEventDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'operationName': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'html': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'text': string | null;
    /**
     * 
     * @type {number}
     * @memberof NotificationsEventDto
     */
    'attempt': number;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationsEventDto
     */
    'used': boolean;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'error': object | null;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'senderData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'recipientGroupId': string;
    /**
     * 
     * @type {object}
     * @memberof NotificationsEventDto
     */
    'recipientData': object | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsEventDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsEventScalarFieldEnum = {
    Id: 'id',
    Type: 'type',
    OperationName: 'operationName',
    Subject: 'subject',
    Html: 'html',
    Text: 'text',
    Attempt: 'attempt',
    Used: 'used',
    Error: 'error',
    SenderUserId: 'senderUserId',
    SenderData: 'senderData',
    RecipientGroupId: 'recipientGroupId',
    RecipientUserId: 'recipientUserId',
    RecipientData: 'recipientData',
    ExternalTenantId: 'externalTenantId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type NotificationsEventScalarFieldEnum = typeof NotificationsEventScalarFieldEnum[keyof typeof NotificationsEventScalarFieldEnum];


/**
 * 
 * @export
 * @interface NotificationsUser
 */
export interface NotificationsUser {
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'externalUserId': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof NotificationsUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof NotificationsUser
     */
    'NotificationsEvent_NotificationsEvent_recipientUserIdToNotificationsUser'?: Array<NotificationsEvent>;
    /**
     * 
     * @type {Array<NotificationsEvent>}
     * @memberof NotificationsUser
     */
    'NotificationsEvent_NotificationsEvent_senderUserIdToNotificationsUser'?: Array<NotificationsEvent>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationsUserScalarFieldEnum = {
    Id: 'id',
    ExternalTenantId: 'externalTenantId',
    ExternalUserId: 'externalUserId',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt'
} as const;

export type NotificationsUserScalarFieldEnum = typeof NotificationsUserScalarFieldEnum[keyof typeof NotificationsUserScalarFieldEnum];


/**
 * 
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UpdateNotificationsEventDto
 */
export interface UpdateNotificationsEventDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'operationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'html'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'text'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateNotificationsEventDto
     */
    'attempt'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateNotificationsEventDto
     */
    'used'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'error'?: object | null;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'senderData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'recipientGroupId'?: string;
    /**
     * 
     * @type {object}
     * @memberof UpdateNotificationsEventDto
     */
    'recipientData'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateNotificationsEventDto
     */
    'externalTenantId'?: string;
}
/**
 * 
 * @export
 * @interface UpdateWebhookDto
 */
export interface UpdateWebhookDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'eventName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'endpoint'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWebhookDto
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof UpdateWebhookDto
     */
    'headers'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateWebhookDto
     */
    'requestTimeout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookDto
     */
    'workUntilDate'?: string | null;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'endpoint': string;
    /**
     * 
     * @type {boolean}
     * @memberof Webhook
     */
    'enabled': boolean;
    /**
     * 
     * @type {object}
     * @memberof Webhook
     */
    'headers': object | null;
    /**
     * 
     * @type {number}
     * @memberof Webhook
     */
    'requestTimeout': number | null;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'updatedBy': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Webhook
     */
    'workUntilDate': string | null;
    /**
     * 
     * @type {WebhookUser}
     * @memberof Webhook
     */
    'WebhookUser_Webhook_createdByToWebhookUser'?: WebhookUser;
    /**
     * 
     * @type {WebhookUser}
     * @memberof Webhook
     */
    'WebhookUser_Webhook_updatedByToWebhookUser'?: WebhookUser;
    /**
     * 
     * @type {Array<WebhookLog>}
     * @memberof Webhook
     */
    'WebhookLog'?: Array<WebhookLog>;
}
/**
 * 
 * @export
 * @interface WebhookEvent
 */
export interface WebhookEvent {
    /**
     * 
     * @type {string}
     * @memberof WebhookEvent
     */
    'eventName': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookEvent
     */
    'description': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookEvent
     */
    'example': object;
}
/**
 * 
 * @export
 * @interface WebhookLog
 */
export interface WebhookLog {
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'id': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookLog
     */
    'request': object;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'responseStatus': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookLog
     */
    'response': object | null;
    /**
     * 
     * @type {WebhookStatus}
     * @memberof WebhookLog
     */
    'webhookStatus': WebhookStatus;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'webhookId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookLog
     */
    'updatedAt': string;
    /**
     * 
     * @type {Webhook}
     * @memberof WebhookLog
     */
    'Webhook'?: Webhook;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookRole = {
    Admin: 'Admin',
    User: 'User'
} as const;

export type WebhookRole = typeof WebhookRole[keyof typeof WebhookRole];


/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookStatus = {
    Pending: 'Pending',
    Process: 'Process',
    Success: 'Success',
    Error: 'Error',
    Timeout: 'Timeout'
} as const;

export type WebhookStatus = typeof WebhookStatus[keyof typeof WebhookStatus];


/**
 * 
 * @export
 * @interface WebhookTestRequestResponse
 */
export interface WebhookTestRequestResponse {
    /**
     * 
     * @type {object}
     * @memberof WebhookTestRequestResponse
     */
    'request': object;
    /**
     * 
     * @type {string}
     * @memberof WebhookTestRequestResponse
     */
    'responseStatus': string;
    /**
     * 
     * @type {object}
     * @memberof WebhookTestRequestResponse
     */
    'response': object | null;
    /**
     * 
     * @type {WebhookStatus}
     * @memberof WebhookTestRequestResponse
     */
    'webhookStatus': WebhookStatus;
}


/**
 * 
 * @export
 * @interface WebhookUser
 */
export interface WebhookUser {
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'externalTenantId': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'externalUserId': string;
    /**
     * 
     * @type {WebhookRole}
     * @memberof WebhookUser
     */
    'userRole': WebhookRole;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookUser
     */
    'updatedAt': string;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookUser
     */
    'Webhook_Webhook_createdByToWebhookUser'?: Array<Webhook>;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhookUser
     */
    'Webhook_Webhook_updatedByToWebhookUser'?: Array<Webhook>;
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsControllerFindOne', 'id', id)
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerUpdateOne: async (id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationsControllerUpdateOne', 'id', id)
            // verify required parameter 'updateNotificationsEventDto' is not null or undefined
            assertParamExists('notificationsControllerUpdateOne', 'updateNotificationsEventDto', updateNotificationsEventDto)
            const localVarPath = `/api/notifications/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateNotificationsEventDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyNotificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerFindMany(curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsEventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsEventDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationsControllerUpdateOne(id, updateNotificationsEventDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.notificationsControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyNotificationResponse> {
            return localVarFp.notificationsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsEventDto> {
            return localVarFp.notificationsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsEventDto> {
            return localVarFp.notificationsControllerUpdateOne(id, updateNotificationsEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerFindMany(curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateNotificationsEventDto} updateNotificationsEventDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public notificationsControllerUpdateOne(id: string, updateNotificationsEventDto: UpdateNotificationsEventDto, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).notificationsControllerUpdateOne(id, updateNotificationsEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateOne: async (createWebhookDto: CreateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookDto' is not null or undefined
            assertParamExists('webhookControllerCreateOne', 'createWebhookDto', createWebhookDto)
            const localVarPath = `/api/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerDeleteOne', 'id', id)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerEvents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindMany: async (curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerFindOne', 'id', id)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webhook/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerTestRequest: async (createWebhookDto: CreateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookDto' is not null or undefined
            assertParamExists('webhookControllerTestRequest', 'createWebhookDto', createWebhookDto)
            const localVarPath = `/api/webhook/test-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateOne: async (id: string, updateWebhookDto: UpdateWebhookDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookControllerUpdateOne', 'id', id)
            // verify required parameter 'updateWebhookDto' is not null or undefined
            assertParamExists('webhookControllerUpdateOne', 'updateWebhookDto', updateWebhookDto)
            const localVarPath = `/api/webhook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerDeleteOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookLogsControllerDeleteOne', 'id', id)
            const localVarPath = `/api/webhook/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindManyLogs: async (webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('webhookLogsControllerFindManyLogs', 'webhookId', webhookId)
            const localVarPath = `/api/webhook/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (curPage !== undefined) {
                localVarQueryParameter['curPage'] = curPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (webhookId !== undefined) {
                localVarQueryParameter['webhookId'] = webhookId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhookLogsControllerFindOne', 'id', id)
            const localVarPath = `/api/webhook/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerCreateOne(createWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerCreateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerEvents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerEvents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyWebhookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerFindMany(curPage, perPage, searchText, sort, tenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerFindMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookTestRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerTestRequest(createWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerTestRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookControllerUpdateOne(id, updateWebhookDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookControllerUpdateOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerDeleteOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerDeleteOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindManyWebhookLogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerFindManyLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookLogsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhookApi.webhookLogsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhookApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerCreateOne(createWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.webhookControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerEvents(options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookEvent>> {
            return localVarFp.webhookControllerEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyWebhookResponse> {
            return localVarFp.webhookControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerProfile(options?: RawAxiosRequestConfig): AxiosPromise<WebhookUser> {
            return localVarFp.webhookControllerProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateWebhookDto} createWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<WebhookTestRequestResponse> {
            return localVarFp.webhookControllerTestRequest(createWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateWebhookDto} updateWebhookDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.webhookControllerUpdateOne(id, updateWebhookDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.webhookLogsControllerDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {number} [curPage] 
         * @param {number} [perPage] 
         * @param {string} [searchText] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<FindManyWebhookLogResponse> {
            return localVarFp.webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookLog> {
            return localVarFp.webhookLogsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
    /**
     * 
     * @param {CreateWebhookDto} createWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerCreateOne(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerCreateOne(createWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerEvents(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerFindMany(curPage?: number, perPage?: number, searchText?: string, sort?: string, tenantId?: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerFindMany(curPage, perPage, searchText, sort, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerProfile(options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateWebhookDto} createWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerTestRequest(createWebhookDto: CreateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerTestRequest(createWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateWebhookDto} updateWebhookDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookControllerUpdateOne(id: string, updateWebhookDto: UpdateWebhookDto, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookControllerUpdateOne(id, updateWebhookDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerDeleteOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {number} [curPage] 
     * @param {number} [perPage] 
     * @param {string} [searchText] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerFindManyLogs(webhookId: string, curPage?: number, perPage?: number, searchText?: string, sort?: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerFindManyLogs(webhookId, curPage, perPage, searchText, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public webhookLogsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return WebhookApiFp(this.configuration).webhookLogsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }
}



